---
title: 前端笔试面试知识记录
category: [学习笔记,笔试,面试]
tag: [前端开发]
date: 2018-03-13 15:29:56
---

进入研一下半学期要找实习了，我想先在这里将自己能想到的、别人在笔试面试过程中遇到的前端知识点记录一下，做一个总结，方便自己随时复习，也能够加深自己对这部分知识的印象。<!--more-->

## JavaScript

### 创造对象的方式

#### 工厂模式

这是最简单的创建对象的方法。

``` javascript
function createObject(name) {
  var temp = new Object()
  temp.name = name
  temp.sayName = function () {
    console.log(this.name)
  }
}

var person = createObject('Tom')
```

#### 构造函数

使用的时候比工厂模式更简单方便一点

``` javascript
function Person(name) {
  this.name = name
  this.sayName = function () {
    console.log(this.name)
  }
}

var person = new Person('Tom')
```

构造函数这种方式存在一个问题，就是每个实例对象中的方法原本都是相同的逻辑，但是实例的方法互相之间不能复用，从而造成了内容资源的浪费，可以通过下面这段代码查看这个问题。

``` javascript
var person1 = new Person('Tom')
var person2 = new Person('John')

console.log(person1.sayName === person2.sayName) /* false */
```

#### 原型模式

为了解决上面存在的问题。

``` javascript
function Person() {}

Person.prototype.name = 'Tom'
Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person()
```

这样每个实例的方法互相之间就是共享的，从而避免了内存资源浪费的问题。

但是这种方法又存在另外的问题，一是不能在调用构造函数生成对象的时候传递参数，另外原型对象中引用类型的变量在每个实例之间也是共享的，一个实例修改了这个引用类型的变量，也会在其他实例中引起变化，因此简单来说就是复用过头了。

#### 组合使用构造函数与原型模式

为了解决上面存在的问题，采取的方法是，将需要共享的方法放在原型对象中，不需要共享的属性就在构造函数中初始化。

``` javascript
function Person(name) {
  this.name = name
}

Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person()
```

对于创建对象这个需求，这种方法算是比较好的方法，也是使用最广泛、认同度最高的一种创建自定义对象的方法。

#### 动态原型模式

对上面组合使用构造函数与原型模式的一种更进一步的方法，能够将属性初始化与原型初始化一起放在构造函数中初始化。

``` javascript
function Person(name) {
  this.name = name

  if (!Person.prototype.sayName) {
    Person.prototype.sayName = function () {
      console.log(this.name)
    }
    /* 其他要放在原型对象中的方法 */
  }
}

var person = new Person()
```

这种动态原型模式就将属性初始化和原型初始化放在了一起，实际检测的时候，只需要检测要在原型中添加的众多方法中的一个，如果没有定义，就说明当前是第一次执行构造函数，所以需要将放在原型中的方法都初始化定义一遍，以后再执行构造函数的时候，因为原型中的方法已经初始化定义过一次了，所以不会再次执行初始化代码。

#### 寄生构造函数模式

应该说这种方法与工厂模式没有实质性的区别，但是所要表达的意思不太相同，寄生构造函数模式更像是一个增强函数，它基于一个已经存在的对象类型，在不对这个已经存在的对象类型做出修改的前提下，对其进行增强，比如添加另外的属性和方法。

``` javascript
function enhanceArray() {
  var temp = new Array()
  temp.push.apply(temp, arguments)
  temp.toPipedString = function () {
    return this.join('|')
  }
  return temp
}

var colors = enhanceArray('red', 'blue', 'yellow')
colors.toPipedString()  /* red|blue|yellow */
```

可以看到上面这个寄生构造函数模式是对数组这个原生对象类型进行了增强，在不影响原始的 Array 构造函数的前提下，对其进行了增强，添加了一个方法用于将数组中的每一项以“|”为分隔符组合成一个字符串。如果不使用这种寄生构造函数模式，而是直接在 Array 构造函数的原型对象 prototype 中添加这个方法，那么就会对所有的数组实例产生影响，因为每个数组实例都可以通过原型链访问到这个方法。

#### 稳妥构造函数模式

两个要求，一是对象的方法中不使用 this，二是不使用 new 操作符来调用构造函数。

### JavaScript 实现继承的方式

#### 原型链

原型链在 JavaScript 中是实现继承的最简单也是最常用的一种方法。

``` javascript
function SuperType() {
  this.name = 'Tom'
}

function SubType() {}

SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType()
```

原型链存在两个问题，一个是父类属性中属于引用类型的属性，在所有的子类实例中都是共享的，其中一个子类实例修改了这个引用类型的属性，那么就会在其他所有子类实例中反映出来，二是这种方法在调用子类构造函数生成子类实例时不能向父类的构造函数中传递参数。

#### 借用构造函数

为了解决上面存在的问题，将父类中的属性在子类实例上全部初始化一遍，并且能够在调用子类构造函数时传递参数给父类。

``` javascript
function SuperType(name) {
  this.name = name
}

function SubType(name) {
  SuperType.call(this, name)
}

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType('Tom')
```

借用构造函数这种方法同样存在一个问题，那就是如果父类中有方法的话，则父类的方法就必须直接写在构造函数中而不能写在构造函数的原型对象中（因为借用构造函数的方式导致父类不在子类的原型链上），那么相当于父类中定义的方法最后在子类实例中也全部都定义了一遍，导致执行相同逻辑的方法不能够得到有效复用，浪费了内存资源。

#### 组合继承

为了解决上面存在的问题，方法是将父类的属性定义放在构造函数中，父类的方法定义放在父类构造函数的原型对象中，通过借用构造函数方法实现子类对父类属性的继承，通过原型链实现子类对父类方法的继承。

``` javascript
function SuperType(name) {
  this.name = name
}

SuperType.prototype.sayName = function () {
  console.log(this.name)
}

function SubType(name) {
  SuperType.call(this, name)
}

SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType('Tom')
```

通过组合继承的方法来实现继承是一种比较好的解决办法。

#### 原型式继承

在一些情况下，我们可能不需要兴师动众地调用构造函数来实现继承，而是仅仅想让一个对象与另外一个对象保持相似关系，比如在这个对象上拥有的属性，也希望在另外一个对象上访问到并使用，那么就可以使用原型式继承方法。

``` javascript
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

这个方法要求传入一个对象，之后在内部动态生成并返回了一个新对象，而传入的对象在这个新对象的原型链上，因此传入的对象所拥有的属性和方法，也可以被这个新对象通过原型链的方式访问到。

#### 寄生式继承

这个方法与前面的原型式继承差别不大，它多出来的工作就是将其他一些对新对象的操作都包装起来，例如要在原型式继承方法返回的新对象上再增加一个新的属性和方法，则可以使用这种寄生式继承方法。

``` javascript
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function createAnother(original) {
  var temp = object(original)
  temp.name = 'Tom'
  temp.sayName = function () {
    console.log(this.name)
  }
  return temp
}

var instance = createAnother(new Object())
```

寄生式继承同样存在子类方法不能复用的问题，每一个子类实例的方法互相之间都是不相同的，这浪费了内存资源。

另外，我们回过头去看组合继承，可以发现其实组合继承也是有问题的，那就是父类构造函数实际上会执行两次，第一次是在将子类的 prototype 指定为父类实例时，第二次是在每个子类实例初始化时，这就导致在父类构造函数中定义的属性会被定义两次，且这两次定义分别定义在了不同的地方，一处是在子类实例 `instance` 上，还有一处是在 `instance.__proto__` 上，而且前者一定会覆盖后者，这实在是一种不好的处理方式，而且浪费了内存资源。

#### 寄生组合式继承

这个方法可以说是实现继承最好的方法，它能够有效避免寄生式继承所遇到的问题。它的思想是将寄生式继承和组合式继承结合起来，它利用组合式继承来实现对父类属性的继承，利用寄生式继承来实现对父类方法的继承。

``` javascript
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function createAnother(original) {
  var temp = object(original)
  return temp
}

function SuperType(name) {
  this.name = name
}

SuperType.prototype.sayName = function () {
  console.log(this.name)
}

function SubType(name) {
  SuperType.call(this, name)
}

SubType.prototype = createAnother(SuperType.prototype)
SubType.prototype.constructor = SubType

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType('Tom')
```

可以看到与组合式继承所不同的是，父类的构造函数没有执行两次，原本将子类的 prototype 指定为父类实例的代码，改为了只将父类的 prototype 属性进行了一次浅复制，最后生成的实例其原型链大抵如下所示

``` javascript
{
  name: 'Tom',
  __proto__: {
    constructor: SubType,
    sayName: function () {
      console.log(this.name)
    },
    __proto__: {
      sayName: function () {
        console.log(this.name)
      }
    }
  }
}
```

从上面的执行结果可以明显看出，父类的方法得到了很好继承，而子类自己的方法也得到了继承，而且父类与子类的每一个方法都是共用的，从而有效避免了寄生式继承所遇到的问题，父类构造函数也只执行了一次，因此属性只继承了一次，从而有效避免了组合式继承所遇到的问题。目前看来，寄生组合式继承是所有继承方法中应用最广泛、最有效、也最好的一种方法。

### 事件

#### 事件冒泡

事件冒泡，即事件开始时，由最具体的元素接收，然后逐级向上传播到较为不具体的节点，这是一种从下往上的事件流，它会在当前节点、当前节点的父节点、当前节点的祖节点依次被触发，一直传播到 document 对象。事件冒泡最开始在 IE 浏览器上被实现。

#### 事件捕获

事件捕获的思想是不太具体的节点，应该更早接收到事件，而最具体的节点应该最后接收到事件，事件捕获的用意在于，在事件到达预定目标之前捕获它。

#### DOM 事件流

DOM二级事件规定的事件流包括三个阶段，它们分别是事件捕获阶段，处于目标阶段和事件冒泡阶段。首先发生的事件捕获，为截获事件提供了机会，然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件作出响应。

#### 事件处理程序

事件处理程序分为DOM零级和DOM二级，DOM零级是直接指定事件属性为某一个处理函数，DOM二级是通过 addEventListener 和 removeEventListener 实现的，它们指定的事件名不要带“on”，它们都接收三个参数，其中最后一个参数是一个布尔值，如果这个布尔值参数为真，则表示在捕获阶段调用事件处理程序，如果为假，则表示在冒泡阶段调用事件处理程序。

#### 阻止浏览器的默认行为

在 IE 浏览器中，需要将 event 对象的 returnValue 设置为 false，在其他浏览器中需要调用 preventDefault() 函数。

#### 阻止事件的进一步冒泡或捕获

在 IE 浏览器中，需要将 event 对象的 cancelBubble 设置为 true，在其他浏览器中需要调用 stopPropagation() 函数。

### React

#### React 组件的生命周期

React 组件有关生命周期的函数分别有 constructor、componentWillMount、render、componentDidMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate、componentWillUnmount，下面分别说明它们的执行时机。

#### constructor

constructor 只会在组件生成的时候被执行一次，并且这个函数里面执行的第一句代码一定要是 `super(props)`，因为所有的组件都继承自 React 的 Component 或者 PureComponent，如果不先执行这句代码，那么子类就没有 this 对象，从而导致新建实例的时候报错。在这个函数里面，还可以执行对组件状态的初始化，绑定组件当中的事件处理程序等。

#### componentWillMount

componentWillMount 同样只会在组件生成的时候被执行一次，可以在这个函数里面向后端发起请求，获取当前页面所需要的数据。

#### render

render 会在组件的整个生命周期中不断被执行，只要组件的数据发生了变化，不管是属性变化，还是自身状态发生变化，最终都会触发 render 函数，重新渲染出页面结构，从而保证数据与页面显示的对应关系。

#### componentDidMount

componentDidMount 会在组件的 render 函数第一次执行完毕以后被触发执行，在组件的整个生命周期过程中，同样只会被执行一次。

#### componentWillReceiveProps

componentWillReceiveProps 会在组件的属性发生变化之后被执行，但我从《深入浅出 React 与 Redux》这本书中了解到，只要当前组件的父组件发生渲染，执行了 render 函数，那么该父组件下的所有子组件和后代组件都会触发 componentWillReceiveProps 函数并执行。

#### shouldComponentUpdate

shouldComponentUpdate 会在组件的属性或自身状态发生变化之后，被触发执行，这个函数的主要作用是用来优化 React 组件的性能，它一共接收两个参数，分别是组件下一次将要被渲染的属性和状态，通过比较下一次将要被渲染的属性和状态与当前的属性和状态，可以在某些不必要的时候，取消组件的重新渲染，该函数默认返回真，如果返回假，则不会执行 render 函数，从而阻止组件的重新渲染。

#### componentWillUpdate

componentWillUpdate 会在组件的属性或自身状态发生变化，且 shouldComponentUpdate 函数返回真的情况下，被触发执行。

#### componentDidUpdate

componentDidUpdate 会在 componentWillUpdate 函数和 render 函数执行完成以后被触发执行。

#### componentWillUnmount

componentWillUnmount 会在组件将要被卸载的时候触发执行，一般在这个函数中主要做一些清除定时器、一些不再使用的变量等工作。

### Redux

随着页面数据的增多，单纯地使用 React 自身的状态方法来管理数据是一项很费力的工作，各个组件之间的状态管理会变得越来越难以维护。Redux 的出现就是为了改变这种情况，它将组件的状态统一维护成一个状态树，任何改变状态数据的方法都是通过 Redux 来触发，这样只需要维护这个最顶层的状态树就行了。下面分文件对 Redux 的实现进行讨论。

#### createStore.js

``` javascript
import isPlainObject from 'lodash/isPlainObject'
import $$observable from 'symbol-observable'

/* Redux 自己创建的 Action，会在每次初始化状态树的时候被触发 */
export const ActionTypes = {
  INIT: '@@redux/INIT'
}

export default function createStore(reducer, preloadedState, enhancer) {
  /* 如果第二个参数为方法且第三个参数为空，则将两个参数交换 */
  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }

  /* enhancer 和 reducer 必须为 function 类型 */
  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }
    /* 用 enhancer 包装一次 createStore 方法，再调用无 enhancer 的 createStore 方法，这里的代码只会在 enhancer 有效的时候被执行，因此再次调用 createStore 的时候不会再执行这部分代码 */
    return enhancer(createStore)(reducer, preloadedState)
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.')
  }

  let currentReducer = reducer //当前的reducer函数
  let currentState = preloadedState //当前的state树
  let currentListeners = []      //监听函数列表
  let nextListeners = currentListeners  //监听列表的一个引用
  let isDispatching = false      //是否正在dispatch

  /* 如果当前监听列表没有发生变化，则浅拷贝一份当前的监听列表 */
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }

  /* 下面的函数被 return 出去，函数作为返回值，则形成了闭包，currentState 等状态会被保存 */
  
  /* 返回当前 state 树 */
  function getState() {
    /* 直接返回当前 Redux 的状态树 */
    return currentState
  }

  /* 添加注册一个监听函数，返回一个可以取消此监听的方法 */
  function subscribe(listener) {
    /* 要求传进来的参数是一个函数，这很好理解，因为需要添加的是监听函数 */
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.')
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    /* 将新添加的监听函数添加到 Redux 自己的监听函数列表中 */
    nextListeners.push(listener)

    /* 返回一个针对这个新添加的监听函数的取消监听方法 */
    return function unsubscribe() {
      /* 确保要被取消的监听函数处于有效监听状态，如果已经失效，则直接返回 */
      if (!isSubscribed) {
        return
      }

      /* 将监听函数是否有效的标志位置为 false，也就是当前这个监听函数已经被取消过，失效了 */
      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      /* 数组的 splice 方法，第一个参数指从哪个位置开始操作数组，第二个参数表示从指定位置开始一共需要删除多少个数组元素，第三个参数表示需要在空缺位置填补进去的数据 */
      nextListeners.splice(index, 1)
    }
  }

  /* 派发一个 Action 来修改 Redux 中的状态树 */
  function dispatch(action) {
    /* 要求 action 是一个对象，而且这个对象的原型是 Object.prototype 或者 null，一般来说对象字面量可以满足这个条件，因此 action 对象可以直接通过对象字面量来初始化 */
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'
      )
    }

    /* 要求每一个 action 对象都要有一个 type 属性 */
    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
        'Have you misspelled a constant?'
      )
    }

    /* 如果正处于 isDispatching 状态就会报错，这说明不能在同一时间内同时触发两个 action，我个人觉得可能是为了防止出现类似多进程竞争的情况出现，因此规定同一时间内只能有一个 action 对 Redux 的状态树做改动 */
    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      /* 设置状态位 */
      isDispatching = true
      /* 这里就是调用我们 reducer 方法修改状态树的地方，调用的时候为我们的 reducer 传递了两个参数，一个是当前的状态树 currentState，还有一个就是 action 对象，最后返回一个新的 state 作为 currentState */
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    /* 依次执行所有的监听函数，另外还要保证新增的监听函数也要被执行，因此才会有后面的连等操作 */
    const listeners = currentListeners = nextListeners
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    /* 最后返回 action 对象，虽然我不太清楚返回这个有什么用 */
    return action
  }

  /* 替换当前 reducer */
  function replaceReducer(nextReducer) {
    /* 确保传递进来的 reducer 是一个函数，因为在上面的 dispatch 函数中可以明显看到 dispatch 一个 action 以后需要调用 reducer 并为其传递两个参数来生成新的状态树 */
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.')
    }

    currentReducer = nextReducer
    /* 每次更换状态树以后，都应该初始化状态树 */
    dispatch({ type: ActionTypes.INIT })
  }

  /* 这个方法用于提供观察者模式，在这里暂时先不做讨论 */
  function observable() {
    const outerSubscribe = subscribe
    return {
      subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.')
        }

        function observeState() {
          //观察者模式的链式结构，传入当前的state
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }

  /* 当store被创建的时候，初始化状态树 */
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
```

通过上述代码可以看出，createStore 方法最后通过闭包的形式，返回了几个可以对状态树进行查询修改操作的方法，而且也因为使用了闭包，使得内部的各个变量也被持久化存储了。

#### compose.js

``` javascript
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

代码非常简介，首先将传递进来的未知数量的函数参数通过 ES6 的剩余参数语法全部转存到 funcs 这个数组中，然后对传递进来的函数参数进行具体判断，如果没有函数作为参数被传递进来，那么就会返回一个直接将参数作为返回值的函数（类似于什么也不做的空函数），如果有一个函数参数被传递进来，那么就直接返回这个函数，最关键的部分是最后一行代码，也是这个函数的精髓所在，这句代码非常简练，可能不太方便理解，我们将它转换成另外一种表达方式。

``` javascript
funcs.reduce(function (a, b) {
  var tempFunc = function (...args) {
    var tempValue1 = b(...args)
    var tempValue2 = a(tempValue1)
    return tempValue2
  }
  return tempFunc
})
```

这句代码的执行流程大概是这样的，首先，前面已经判断过了没有传入函数参数和只传入了一个函数参数的情况，那么如果前面两种情况都不是，则说明传入的函数参数要两个或两个以上，这里对函数参数数组调用了 reduce 方法，那么第一次执行的时候，先取函数参数数组 funcs 中的前两个函数，分别赋值给 a 和 b，然后返回了一个函数 tempFunc，这个 tempFunc 函数将传入的参数转存到 args 数组中，然后在内部先调用了 b 函数并将参数数组 args 解构后传递给了 b 函数，然后又将 b 函数的返回值 tempValue1 作为 a 函数的参数，执行了 a 函数以后返回了 a 函数执行完成后的返回值 tempValue2，到这里第一次循环就完成了；之后进行第二次循环，第二次循环与第一次循环有些许差别，具体在于 a 参数，这个时候并不是将函数参数数组 funcs 的第三个和第四个函数分别赋值给 a 和 b，而是将上一次返回的 tempFunc 函数赋值给 a，将函数参数数组 funcs 的第三个函数赋值给 b，然后重新返回了一个新的 tempFunc 函数，在这个新的 tempFunc 函数中，仍然是将传入的参数转存到了 args 数组中，然后在内部先调用了 b 函数并将参数数组 args 解构后传递给了 b 函数，然后又将 b 函数的返回值 tempValue1 作为 a 函数（也就是上一次循环返回的 tempFunc 函数）的参数，执行了 a 函数以后返回了 a 函数执行完成后的返回值 tempValue2，这样第二次循环也完成了；后面的循环所执行的动作与前面所说的基本相同，最后的执行结果就是，返回了一个将函数参数数组 funcs 中的所有函数进行链式调用以后的执行结果。下面让我们来看一段代码。

``` javascript
function test1(value) {
  console.log('test1', value)
  value.value1 = 'test1'
  return value
}
function test2(value) {
  console.log('test2', value)
  value.value2 = 'test2'
  return value
}
function test3(value) {
  console.log('test3', value)
  value.value3 = 'test3'
  return value
}
function test4(value) {
  console.log('test4', value)
  value.value4 = 'test4'
  return value
}
function test5(value) {
  console.log('test5', value)
  value.value5 = 'test5'
  return value
}
function test6(value) {
  console.log('test6', value)
  value.value6 = 'test6'
  return value
}
function test7(value) {
  console.log('test7', value)
  value.value7 = 'test7'
  return value
}

var funcs = [
  test1,
  test2,
  test3,
  test4,
  test5,
  test6,
  test7,
]

var resultFunc = funcs.reduce((a, b) => (...args) => a(b(...args)))
```

在上面的代码中，我们定义了七个函数，它们的共同特点就是，首先打印当前处于哪个函数中，然后对传入的参数做一定的改动，在这里改动就是为参数加上当前函数的名字，最后返回经过改动以后的参数。根据上面的分析，我们可以知道最后的 resultFunc 变量应该是一个将上面七个函数组合后进行链式调用的函数，它的样子应该类似于下面这样。

``` javascript
var resultFunc = (...args) => test1(test2(test3(test4(test5(test6(test7(...args)))))))
```

函数参数数组中处于前面的函数应当位于链式调用的外侧，处于后面的函数应当位于链式调用的内侧。

下面我们调用一下这个函数看看。

``` javascript
var result = resultFunc({})
```

出现的结果应该是下面这个样子。

``` javascript
'test7' {}
'test6' {value7: 'test7'}
'test5' {value7: 'test7', value6: 'test6'}
'test4' {value7: 'test7', value6: 'test6', value5: 'test5'}
'test3' {value7: 'test7', value6: 'test6', value5: 'test5', value4: 'test4'}
'test2' {value7: 'test7', value6: 'test6', value5: 'test5', value4: 'test4', value3: 'test3'}
'test1' {value7: 'test7', value6: 'test6', value5: 'test5', value4: 'test4', value3: 'test3', value2: 'test2'}
```

那么现在你应该猜到了 result 是什么样子了吧？

``` javascript
{
  value1: 'test1',
  value2: 'test2',
  value3: 'test3',
  value4: 'test4',
  value5: 'test5',
  value6: 'test6',
  value7: 'test7',
}
```

考虑到 compose 函数经常与 createStore 连用的用法，可以看出其主要就是对 createStore 方法进行增强，通过传入的处理函数新增一些原生 Redux 没有的功能。

#### applyMiddleware.js

``` javascript
export default function applyMiddleware(...middlewares) {
  /* return 一个函数，它可以接受 createStore 方法作为参数，给返回的 store 的 dispatch 方法再进行一次包装 */
  return (createStore) => (reducer, preloadedState, enhancer) => {
    const store = createStore(reducer, preloadedState, enhancer)
    let dispatch = store.dispatch
    let chain = []

    /* 定义一个对象，在里面暴露两个方法给外部函数 */
    const middlewareAPI = {
      /* 获取当前 Redux 的状态树 */
      getState: store.getState,
      /* Redux 的 dispatch 方法 */
      dispatch: (action) => dispatch(action)
    }

    /* 传入 middlewareAPI 参数并执行每一个外部函数，返回结果汇聚成数组 */
    chain = middlewares.map(middleware => middleware(middlewareAPI))

    /* 这里用到了刚才说到的compose方法，如果你忘了，返回去看一下 */
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}
```

由上面的代码可以看出，applyMiddleware 函数接收若干个中间件，并将其转存到参数数组 middlewares 中，然后返回了一个函数，这个函数接收 createStore 方法作为参数，结合其经常与 compose 连用的用法和上面对 compose 函数用法的讨论，可以知道这个返回的函数作用就是对 createStore 方法进行增强，而且其似乎专门针对 Redux 的 dispatch 方法进行增强，而增强的手段就是通过传入的若干个中间件实现的，每一个中间件都接收一个对象作为参数，该对象包含了获取当前 Redux 状态树和 Redux 原生的 dispatch 方法，然后将每一个中间件的执行结果保存在一个数组中，最后将这个数组解构后作为参数传入了 compose 方法中，从这里我们也可以看出每一个中间件执行完成后返回的结果应该也是一个函数，且该函数接收 Redux 原生的 dispatch 方法作为参数，并以此对其进行修改或者说增强，最后替换掉 Redux 原生的 dispatch 方法。

在这里我们实际查看一个中间件的代码，看看与我们上面的分析是否吻合。这个中间件的名字叫做 redux-thunk，是一个用来实现异步 dispatch 的工具库。

``` javascript
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```

代码非常简练，可以看出该工具库最终导出了一个函数，并且给这个函数添加了一个属性（函数本质上也是对象，因此也可以添加属性），这个属性就是上面定义的那个 createThunkMiddleware 函数，因为从默认导出的 thunk 就可以看出，其生成的时候并不带有额外参数，所有需要再将可以接受参数的方法也暴露出来，方便在特殊需求的场景下使用（类似于自定义 thunk）。我们所要观察的重点在于 createThunkMiddleware 函数，不传入任何参数调用它就会返回默认导出的 thunk，这是一个函数，它默认接受一个对象作为参数，且要求这个对象参数要有 dispatch 和 getState 方法，看到这里应该就可以联想到，对应到上面的 applyMiddleware 方法实现中的 middlewareAPI，它执行完成以后仍然返回一个函数，这个函数接受一个函数参数，虽然在这里叫做 next，但是对应到上面的 applyMiddleware 方法就可以很明显的看出，next 就是 store.dispatch，也就是 Redux 的原生的 dispatch 方法，在 createThunkMiddleware 实际应用的时候也是这样，next 接受了一个 action 对象作为参数，这就是标准的 dispatch 方法的使用，这个函数执行完以后，返回值仍然是一个函数，其接受 action 对象作为参数，其实这就是最后包装好以后的 dispatch 方法，我们可以看下里面到底做了些什么，首先对 action 的类型做了判断，查看其是否是一个函数类型，看到这里你可能会觉得很疑惑，之前不是已经规定好了 action 只能是一个必须带有 type 属性且原型要为 Object.prototype 或者 null 的对象吗？为什么这里竟然会判断其是否为一个函数，其实这里就需要知晓我们为什么要使用 redux-thunk 了，在 Redux 中所有的操作都是同步的，这一点可以在上面的 createStore 方法中看到，程序通过 dispatch 触发了一个 action 来修改 Redux 状态树上的数据，整个过程都是同步进行的，而有的时候这会给我们带来困境，最常见的困境就是向后端服务器请求数据时的困境，程序通过 dispatch 触发了一个 action 来向后端服务器请求数据，但是很明显这个过程是异步进行的，不可能说发送请求以后数据马上就收到了，当然也可以将请求改为同步模式，但这样做显然得不偿失，向后端服务器请求数据本来就是一个不可预测的事情，整个数据请求操作能否成功暂且不说，整个请求耗费的时间就不是我们可以控制的，如果用户的网络速度比较慢，那么请求耗费的时间需要十几秒钟甚至几十秒钟，而同步请求就会造成在这段时间中页面卡在请求这里，这种用户体验简直是毁灭性的，因此几乎所有向后端服务器请求数据的操作都是异步的，而 Redux 中所有的操作都是同步的，为了调和这种矛盾，redux-thunk 就想出了一种办法，允许开发人员给 dispatch 传递一个函数类型的 action，然后在上面所说的对 Redux 的原生 dispatch 方法进行改造升级的过程中，对这种特殊的 action 做了拦截，这也就回到了我们最开始有疑问的地方，如果检测到传入的 action 是一个函数，那么就进入特殊的处理模式，也就是调用执行这个函数，并向这个函数中传递三个参数，第一个是 Redux 原生的 dispatch 方法，第二个是 Redux 的获取当前状态树的方法，第三个是一个额外参数，如果使用 redux-thunk 默认导出的 thunk，那么这个参数就是 undefined，这里加上 return 并不是指望要返回什么值，我感觉就是单纯地跳过下面的代码不去执行，如果传入的 action 不是一个函数，那么就执行正常操作，也就是通过 Redux 的原生 dispatch 方法触发一个 action，修改 Redux 的状态树，注意 Redux 的原生 dispatch 方法的返回值，其最后将 action 对象原封不动地返回了回来，因为可能程序中并不只使用了一个中间件，使用了多个中间件的时候，它们都要求将 action 对象作为参数传入，然后依次链式执行，看到这里你可能就会联想到上面介绍的 compose 方法，没错，就是因为它将所有的中间件最后组合成了一个链式调用的函数，而外侧函数都以内侧函数的返回值作为参数，因此需要内侧函数返回它所接收到的参数，而这个参数在这里就是 action 对象。

另外，我还想问下，redux-logger 这个中间件要求将自己放在所有中间件的最后面，如果放在前面某一个位置的话，有可能会遗漏掉某些 action，这是为什么呢？其实这里的根本原因就是 compose 方法，compose 方法在将函数数组转换为一个链式调用函数的时候，最前面的函数处于最外侧，而最后面的函数处于最内侧，很明显最内侧的函数最先被执行，redux-logger 要求将自己放在最后面就是为了防止类似于 redux-thunk 这种奇葩在 redux-logger 执行之前将 action 拦截，那样就记录不到任何 action 数据了，而将 redux-logger 放在最后面的时候，redux-logger 最先执行，所有的 action 都得先经过它这一关，至于后面的中间件们怎么处理 action，那就不是它所关心的事情了。

#### bindActionCreators.js

``` javascript
import warning from './utils/warning'

function bindActionCreator(actionCreator, dispatch) {
  return (...args) => dispatch(actionCreator(...args))
}

/**
 * 将 action 与 dispatch 函数绑定，生成直接可以触发 action 的函数，
 * 可以将第一个参数对象中所有的 action 都直接生成可以直接触发 dispatch 的函数
 * 而不需要一个一个的 dispatch，生成后的方法对应原来 action 生成器的函数名
 * */
export default function bindActionCreators(actionCreators, dispatch) {
  /* actionCreators 要求要么是函数，要么是对象 */
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch)
  }
    
  /* 如果 actionCreators 不是函数，那么就必须为对象类型 */
  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error(
      `bindActionCreators expected an object or a function, instead received ${actionCreators === null ? 'null' : typeof actionCreators}. ` +
      `Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`
    )
  }

  /* 获取对象 actionCreators 的所有属性，也就是所有的需要与 dispatch 绑定的 action */
  const keys = Object.keys(actionCreators)
  const boundActionCreators = {}
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    
    /* 给 actionCreators 的每一个成员都绑定 dispatch 方法生成新的方法， */
    /* 然后注入新的对象中，新方法对应的 key 即为原来在 actionCreators 的名字 */
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    } else {
      warning(`bindActionCreators expected a function actionCreator for key '${key}', instead received type '${typeof actionCreator}'.`)
    }
  }
  return boundActionCreators
}
```

这个文件中的 bindActionCreators 作用很单一，就是为了将 action 与 dispatch 对象绑定，生成可以直接触发 action 的函数。

### Immutable

在 JavaScript 中数组和对象一般是可变的，因为数组和对象都是引用类型，JavaScript 采用引用类型的策略是有根据的，因为这可以显著节约内存，但是这样做也存在很大的问题，当应用变得大而复杂的时候，这会造成很大的隐患，因为越是灵活的数据越是不好控制，在这些复杂应用中，我们可能会一不小心就修改了某个数据，而其他用到了这个数据的地方也被因此被影响到，而且因为应用的复杂性，我们很难及时精确地找出数据是在何时何地被修改了的。而 Immutable 数据则没有这个问题，每次针对 Immutable 数据进行修改，都会返回一个新的 Immutable 数据，而原来的 Immutable 数据则不会产生任何变化，这一点在 Redux 中得到的很好的应用，Redux 要求 reducer 不能对作为参数传入的 currentState 做出任何改动（因为如果对传入的 currentState 做出了修改的话，就违反了 Redux 关于状态树只能由 dispatch 某个 action 来修改的规定，破坏了单项数据流模式，给数据管理带来不可预测的变化），需要返回一个全新的 state，如果不使用 Immutable 数据，那么就需要对原来的 currentState 做一个深拷贝，然后对这个深拷贝的数据进行修改，并在最后返回，但是深拷贝是一个非常耗费性能的操作，且保存两个完全一模一样的数据也浪费了内存资源，因此这种办法效果是很不好的，而 Immutable 数据则不存在这种问题，Immutable 数据默认对任何修改操作都返回新的 Immutable 数据而不会对原数据遗留影响，而且 Immutable 数据内部对数据的存储也不会完全保存两份一模一样的数据，其使用了一种叫做 `Structure Sharing` 的方法，会尽量复用内存，没有被引用的 Immutable 数据会被垃圾回收机制回收。

这里是一个 Immutable 数据发生修改后，数据在内存中的变动情况。[点击这里查看示意图](http://img.alicdn.com/tps/i2/TB1zzi_KXXXXXctXFXXbrb8OVXX-613-575.gif)

除此之外，在 React 应用中，有一个提升组件性能的大杀器：shouldComponentUpdate，该函数默认接收两个参数，分别是下一次要渲染的组件属性和状态，如果返回的结果是 true，则会触发组件渲染功能，执行 render 函数，如果返回的结果是 false，则不会执行后面的任何操作，从而避免重复无用的渲染，提升组件性能，如果使用原生的 JavaScript 数组和对象，就会面临引用不同，但值相同的问题，也就是下面这种情况。

``` javascript
console.log({} === {}) /* false */
```

因为引用类型通过 === 操作符进行比较的时候，比较的实际上是内存地址，但是很明显，每个新生成的对象，它们的内存地址都是不相同的，我们如果想避免出现这种情况，就需要去深入比较两个引用类型的每一个值，并且在再次碰到引用类型的值时，还需要进一步递归进去比较，这实际上就是所说的“深比较”，这是一个深度遍历比较过程，比较耗费性能，而如果使用 Immutable 数据类型的话，Immutable 提供了一个 is 方法，它比较的是两个对象的 hashCode，只要两个 Immutable 对象的 hashCode 相等，那么它们的值就是一样的，这样的算法避免了深度遍历比较过程，性能非常好。























