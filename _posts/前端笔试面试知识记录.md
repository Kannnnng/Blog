---
title: 前端笔试面试知识记录
category: [学习笔记,笔试,面试]
tag: [前端开发]
date: 2018-03-13 15:29:56
---

进入研一下半学期要找实习了，我想先在这里将自己能想到的、别人在笔试面试过程中遇到的前端知识点记录一下，做一个总结，方便自己随时复习，也能够加深自己对这部分知识的印象。<!--more-->

## JavaScript

### 创造对象的方式

#### 工厂模式

这是最简单的创建对象的方法。

``` javascript
function createObject(name) {
  var temp = new Object()
  temp.name = name
  temp.sayName = function () {
    console.log(this.name)
  }
}

var person = createObject('Tom')
```

#### 构造函数

使用的时候比工厂模式更简单方便一点

``` javascript
function Person(name) {
  this.name = name
  this.sayName = function () {
    console.log(this.name)
  }
}

var person = new Person('Tom')
```

构造函数这种方式存在一个问题，就是每个实例对象中的方法原本都是相同的逻辑，但是实例的方法互相之间不能复用，从而造成了内容资源的浪费，可以通过下面这段代码查看这个问题。

``` javascript
var person1 = new Person('Tom')
var person2 = new Person('John')

console.log(person1.sayName === person2.sayName) // false
```

#### 原型模式

为了解决上面存在的问题。

``` javascript
function Person() {}

Person.prototype.name = 'Tom'
Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person()
```

这样每个实例的方法互相之间就是共享的，从而避免了内存资源浪费的问题。

但是这种方法又存在另外的问题，一是不能在调用构造函数生成对象的时候传递参数，另外原型对象中引用类型的变量在每个实例之间也是共享的，一个实例修改了这个引用类型的变量，也会在其他实例中引起变化，因此简单来说就是复用过头了。

#### 组合使用构造函数与原型模式

为了解决上面存在的问题，采取的方法是，将需要共享的方法放在原型对象中，不需要共享的属性就在构造函数中初始化。

``` javascript
function Person(name) {
  this.name = name
}

Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person()
```

对于创建对象这个需求，这种方法算是比较好的方法，也是使用最广泛、认同度最高的一种创建自定义对象的方法。

#### 动态原型模式

对上面组合使用构造函数与原型模式的一种更进一步的方法，能够将属性初始化与原型初始化一起放在构造函数中初始化。

``` javascript
function Person(name) {
  this.name = name

  if (!Person.prototype.sayName) {
    Person.prototype.sayName = function () {
      console.log(this.name)
    }
    /* 其他要放在原型对象中的方法 */
  }
}

var person = new Person()
```

这种动态原型模式就将属性初始化和原型初始化放在了一起，实际检测的时候，只需要检测要在原型中添加的众多方法中的一个，如果没有定义，就说明当前是第一次执行构造函数，所以需要将放在原型中的方法都初始化定义一遍，以后再执行构造函数的时候，因为原型中的方法已经初始化定义过一次了，所以不会再次执行初始化代码。

#### 寄生构造函数模式

应该说这种方法与工厂模式没有实质性的区别，但是所要表达的意思不太相同，寄生构造函数模式更像是一个增强函数，它基于一个已经存在的对象类型，在不对这个已经存在的对象类型做出修改的前提下，对其进行增强，比如添加另外的属性和方法。

``` javascript
function enhanceArray() {
  var temp = new Array()
  temp.push.apply(temp, arguments)
  temp.toPipedString = function () {
    return this.join('|')
  }
  return temp
}

var colors = enhanceArray('red', 'blue', 'yellow')
colors.toPipedString() // red|blue|yellow
```

可以看到上面这个寄生构造函数模式是对数组这个原生对象类型进行了增强，在不影响原始的 Array 构造函数的前提下，对其进行了增强，添加了一个方法用于将数组中的每一项以“|”为分隔符组合成一个字符串。如果不使用这种寄生构造函数模式，而是直接在 Array 构造函数的原型对象 prototype 中添加这个方法，那么就会对所有的数组实例产生影响，因为每个数组实例都可以通过原型链访问到这个方法。

#### 稳妥构造函数模式

两个要求，一是对象的方法中不使用 this，二是不使用 new 操作符来调用构造函数。

### JavaScript 实现继承的方式

#### 原型链

原型链在 JavaScript 中是实现继承的最简单也是最常用的一种方法。

``` javascript
function SuperType() {
  this.name = 'Tom'
}

function SubType() {}

SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType()
```

原型链存在两个问题，一个是父类属性中属于引用类型的属性，在所有的子类实例中都是共享的，其中一个子类实例修改了这个引用类型的属性，那么就会在其他所有子类实例中反映出来，二是这种方法在调用子类构造函数生成子类实例时不能向父类的构造函数中传递参数。

#### 借用构造函数

为了解决上面存在的问题，将父类中的属性在子类实例上全部初始化一遍，并且能够在调用子类构造函数时传递参数给父类。

``` javascript
function SuperType(name) {
  this.name = name
}

function SubType(name) {
  SuperType.call(this, name)
}

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType('Tom')
```

借用构造函数这种方法同样存在一个问题，那就是如果父类中有方法的话，则父类的方法就必须直接写在构造函数中而不能写在构造函数的原型对象中（因为借用构造函数的方式导致父类不在子类的原型链上），那么相当于父类中定义的方法最后在子类实例中也全部都定义了一遍，导致执行相同逻辑的方法不能够得到有效复用，浪费了内存资源。

#### 组合继承

为了解决上面存在的问题，方法是将父类的属性定义放在构造函数中，父类的方法定义放在父类构造函数的原型对象中，通过借用构造函数方法实现子类对父类属性的继承，通过原型链实现子类对父类方法的继承。

``` javascript
function SuperType(name) {
  this.name = name
}

SuperType.prototype.sayName = function () {
  console.log(this.name)
}

function SubType(name) {
  SuperType.call(this, name)
}

SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType

SubType.prototype.sayName = function () {
  console.log(this.name)
}

var instance = new SubType('Tom')
```

通过组合继承的方法来实现继承是一种比较好的解决办法。

#### 原型式继承

在一些情况下，我们可能不需要兴师动众地调用构造函数来实现继承，而是仅仅想让一个对象与另外一个对象保持相似关系，比如在这个对象上拥有的属性，也希望在另外一个对象上访问到并使用，那么就可以使用原型式继承方法。

``` javascript
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}
```

这个方法要求传入一个对象，之后在内部动态生成并返回了一个新对象，而传入的对象在这个新对象的原型链上，因此传入的对象所拥有的属性和方法，也可以被这个新对象通过原型链的方式访问到。

#### 寄生式继承

这个方法与前面的原型式继承差别不大，它多出来的工作就是将其他一些对新对象的操作都包装起来，例如要在原型式继承方法返回的新对象上再增加一个新的属性和方法，则可以使用这种寄生式继承方法。

``` javascript
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function createAnother(original) {
  var temp = object(original)
  temp.name = 'Tom'
  temp.sayName = function () {
    console.log(this.name)
  }
  return temp
}

var instance = createAnother(new Object())
```

寄生式继承同样存在子类方法不能复用的问题，每一个子类实例的方法互相之间都是不相同的，这浪费了内存资源。

另外，我们回过头去看组合继承，可以发现其实组合继承也是有问题的，那就是父类构造函数实际上会执行两次，第一次是在将子类的 prototype 指定为父类实例时，第二次是在每个子类实例初始化时，这就导致在父类构造函数中定义的属性会被定义两次，且这两次定义分别定义在了不同的地方，一处是在子类实例 `instance` 上，还有一处是在 `instance.__proto__` 上，而且前者一定会覆盖后者，这实在是一种不好的处理方式。




















